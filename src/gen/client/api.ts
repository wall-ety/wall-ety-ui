/* tslint:disable */
/* eslint-disable */
/**
 * wallety-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {Bank}
     * @memberof Account
     */
    'bank'?: Bank;
    /**
     * 
     * @type {Balance}
     * @memberof Account
     */
    'balance'?: Balance;
    /**
     * 
     * @type {Client}
     * @memberof Account
     */
    'client'?: Client;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'authorizeCredits'?: string;
}
/**
 * 
 * @export
 * @interface AccountBase
 */
export interface AccountBase {
    /**
     * 
     * @type {string}
     * @memberof AccountBase
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountBase
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountBase
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountBase
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountBase
     */
    'authorizeCredits'?: string;
}
/**
 * 
 * @export
 * @interface ApiErrorResponse
 */
export interface ApiErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiErrorResponse
     */
    'code'?: number;
}
/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface BalanceInfo
 */
export interface BalanceInfo {
    /**
     * 
     * @type {Balance}
     * @memberof BalanceInfo
     */
    'balance'?: Balance;
    /**
     * borrowed money
     * @type {number}
     * @memberof BalanceInfo
     */
    'loan'?: number;
    /**
     * 
     * @type {number}
     * @memberof BalanceInfo
     */
    'loanInterest'?: number;
}
/**
 * 
 * @export
 * @interface Bank
 */
export interface Bank {
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'createdAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Bank
     */
    'authorizeCredits'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Bank
     */
    'firstWeekLoan'?: number;
    /**
     * 
     * @type {number}
     * @memberof Bank
     */
    'subsequentLoan'?: number;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {CategoryType}
     * @memberof Category
     */
    'type'?: CategoryType;
}


/**
 * 
 * @export
 * @interface CategoryStatement
 */
export interface CategoryStatement {
    /**
     * 
     * @type {string}
     * @memberof CategoryStatement
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryStatement
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CategoryType = {
    All: 'ALL',
    Debit: 'DEBIT',
    Credit: 'CREDIT'
} as const;

export type CategoryType = typeof CategoryType[keyof typeof CategoryType];


/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'birthdate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'monthSalary'?: number;
}
/**
 * 
 * @export
 * @interface CompleteAccount
 */
export interface CompleteAccount {
    /**
     * 
     * @type {string}
     * @memberof CompleteAccount
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompleteAccount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompleteAccount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompleteAccount
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompleteAccount
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompleteAccount
     */
    'authorizeCredits'?: string;
}
/**
 * 
 * @export
 * @interface CreateAccount
 */
export interface CreateAccount {
    /**
     * 
     * @type {string}
     * @memberof CreateAccount
     */
    'idClient'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccount
     */
    'idBank'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccount
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccount
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccount
     */
    'authorizeCredits'?: string;
}
/**
 * 
 * @export
 * @interface CreateTransaction
 */
export interface CreateTransaction {
    /**
     * 
     * @type {string}
     * @memberof CreateTransaction
     */
    'idAccount'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransaction
     */
    'id'?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof CreateTransaction
     */
    'type'?: TransactionType;
    /**
     * 
     * @type {string}
     * @memberof CreateTransaction
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTransaction
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateTransaction
     */
    'transactionDatetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransaction
     */
    'label'?: string;
}


/**
 * 
 * @export
 * @interface CreateTransfer
 */
export interface CreateTransfer {
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'destinationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransfer
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface Dummy
 */
export interface Dummy {
    /**
     * 
     * @type {string}
     * @memberof Dummy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dummy
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderValue = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;

export type OrderValue = typeof OrderValue[keyof typeof OrderValue];


/**
 * 
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof Statement
     */
    'credits'?: number;
    /**
     * 
     * @type {number}
     * @memberof Statement
     */
    'debits'?: number;
    /**
     * 
     * @type {number}
     * @memberof Statement
     */
    'balance'?: number;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {Account}
     * @memberof Transaction
     */
    'account'?: Account;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id'?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof Transaction
     */
    'type'?: TransactionType;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'transactionDatetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'label'?: string;
}


/**
 * 
 * @export
 * @interface TransactionBase
 */
export interface TransactionBase {
    /**
     * 
     * @type {string}
     * @memberof TransactionBase
     */
    'id'?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TransactionBase
     */
    'type'?: TransactionType;
    /**
     * 
     * @type {string}
     * @memberof TransactionBase
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionBase
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionBase
     */
    'transactionDatetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionBase
     */
    'label'?: string;
}


/**
 * 
 * @export
 * @interface TransactionStatement
 */
export interface TransactionStatement {
    /**
     * 
     * @type {string}
     * @memberof TransactionStatement
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionStatement
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Debit: 'DEBIT',
    Credit: 'CREDIT'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * 
     * @type {TransferStatus}
     * @memberof Transfer
     */
    'status'?: TransferStatus;
    /**
     * 
     * @type {Client}
     * @memberof Transfer
     */
    'source'?: Client;
    /**
     * 
     * @type {Client}
     * @memberof Transfer
     */
    'destination'?: Client;
    /**
     * 
     * @type {Category}
     * @memberof Transfer
     */
    'category'?: Category;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'sourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'destinationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'label'?: string;
}


/**
 * 
 * @export
 * @interface TransferBase
 */
export interface TransferBase {
    /**
     * 
     * @type {string}
     * @memberof TransferBase
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferBase
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferBase
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferBase
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferBase
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransferDirection = {
    In: 'IN',
    Out: 'OUT',
    All: 'ALL'
} as const;

export type TransferDirection = typeof TransferDirection[keyof typeof TransferDirection];


/**
 * 
 * @export
 * @enum {string}
 */

export const TransferStatus = {
    Pending: 'PENDING',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED'
} as const;

export type TransferStatus = typeof TransferStatus[keyof typeof TransferStatus];



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create or Update list of Accounts
         * @param {Array<CreateAccount>} [createAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateAccounts: async (createAccount?: Array<CreateAccount>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account bank statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBankStatements: async (accountId: string, from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountBankStatements', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/bank-statements`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one Account using id
         * @param {string} accountId Id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountById', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account category statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCategoriesStatements: async (accountId: string, from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountCategoriesStatements', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/categories/statements`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account transactions statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactionsStatements: async (accountId: string, from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountTransactionsStatements', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/transactions/statements`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Account
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {OrderValue} [order] value of your order by
         * @param {string} [idClient] id of the client
         * @param {string} [idBank] id of the bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccounts: async (orderBy?: string, order?: OrderValue, idClient?: string, idBank?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (idClient !== undefined) {
                localVarQueryParameter['idClient'] = idClient;
            }

            if (idBank !== undefined) {
                localVarQueryParameter['idBank'] = idBank;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create or Update list of Accounts
         * @param {Array<CreateAccount>} [createAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateAccounts(createAccount?: Array<CreateAccount>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateAccounts(createAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.crupdateAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Account bank statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBankStatements(accountId: string, from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Statement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBankStatements(accountId, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountBankStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one Account using id
         * @param {string} accountId Id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountById(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountById(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Account category statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountCategoriesStatements(accountId: string, from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryStatement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountCategoriesStatements(accountId, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountCategoriesStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Account transactions statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransactionsStatements(accountId: string, from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionStatement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransactionsStatements(accountId, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountTransactionsStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all Account
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {OrderValue} [order] value of your order by
         * @param {string} [idClient] id of the client
         * @param {string} [idBank] id of the bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAccounts(orderBy?: string, order?: OrderValue, idClient?: string, idBank?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAccounts(orderBy, order, idClient, idBank, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAllAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create or Update list of Accounts
         * @param {Array<CreateAccount>} [createAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateAccounts(createAccount?: Array<CreateAccount>, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.crupdateAccounts(createAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account bank statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBankStatements(accountId: string, from?: string, to?: string, options?: any): AxiosPromise<Array<Statement>> {
            return localVarFp.getAccountBankStatements(accountId, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one Account using id
         * @param {string} accountId Id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById(accountId: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccountById(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account category statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCategoriesStatements(accountId: string, from?: string, to?: string, options?: any): AxiosPromise<Array<CategoryStatement>> {
            return localVarFp.getAccountCategoriesStatements(accountId, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account transactions statements from x to y date
         * @param {string} accountId Id of the account
         * @param {string} [from] date from what you want to retrieve data
         * @param {string} [to] end date from what you want to retrieve data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactionsStatements(accountId: string, from?: string, to?: string, options?: any): AxiosPromise<Array<TransactionStatement>> {
            return localVarFp.getAccountTransactionsStatements(accountId, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Account
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {OrderValue} [order] value of your order by
         * @param {string} [idClient] id of the client
         * @param {string} [idBank] id of the bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccounts(orderBy?: string, order?: OrderValue, idClient?: string, idBank?: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.getAllAccounts(orderBy, order, idClient, idBank, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @summary Create or Update list of Accounts
     * @param {Array<CreateAccount>} [createAccount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public crupdateAccounts(createAccount?: Array<CreateAccount>, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).crupdateAccounts(createAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account bank statements from x to y date
     * @param {string} accountId Id of the account
     * @param {string} [from] date from what you want to retrieve data
     * @param {string} [to] end date from what you want to retrieve data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountBankStatements(accountId: string, from?: string, to?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountBankStatements(accountId, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one Account using id
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountById(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountById(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account category statements from x to y date
     * @param {string} accountId Id of the account
     * @param {string} [from] date from what you want to retrieve data
     * @param {string} [to] end date from what you want to retrieve data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountCategoriesStatements(accountId: string, from?: string, to?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountCategoriesStatements(accountId, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account transactions statements from x to y date
     * @param {string} accountId Id of the account
     * @param {string} [from] date from what you want to retrieve data
     * @param {string} [to] end date from what you want to retrieve data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountTransactionsStatements(accountId: string, from?: string, to?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountTransactionsStatements(accountId, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Account
     * @param {string} [orderBy] string do specify you want to order with what you data
     * @param {OrderValue} [order] value of your order by
     * @param {string} [idClient] id of the client
     * @param {string} [idBank] id of the bank
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAllAccounts(orderBy?: string, order?: OrderValue, idClient?: string, idBank?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAllAccounts(orderBy, order, idClient, idBank, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BalancesApi - axios parameter creator
 * @export
 */
export const BalancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get All Balance by AccountId
         * @param {string} accountId Id of the account
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAccountId: async (accountId: string, order?: OrderValue, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getBalancesByAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current Balance for an Account
         * @param {string} accountId Id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentBalance: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getCurrentBalance', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/balances/current`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalancesApi - functional programming interface
 * @export
 */
export const BalancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get All Balance by AccountId
         * @param {string} accountId Id of the account
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalancesByAccountId(accountId: string, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Balance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalancesByAccountId(accountId, order, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.getBalancesByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Current Balance for an Account
         * @param {string} accountId Id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentBalance(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentBalance(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalancesApi.getCurrentBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BalancesApi - factory interface
 * @export
 */
export const BalancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get All Balance by AccountId
         * @param {string} accountId Id of the account
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesByAccountId(accountId: string, order?: OrderValue, orderBy?: string, options?: any): AxiosPromise<Array<Balance>> {
            return localVarFp.getBalancesByAccountId(accountId, order, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Current Balance for an Account
         * @param {string} accountId Id of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentBalance(accountId: string, options?: any): AxiosPromise<BalanceInfo> {
            return localVarFp.getCurrentBalance(accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
export class BalancesApi extends BaseAPI {
    /**
     * 
     * @summary Get All Balance by AccountId
     * @param {string} accountId Id of the account
     * @param {OrderValue} [order] value of your order by
     * @param {string} [orderBy] string do specify you want to order with what you data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public getBalancesByAccountId(accountId: string, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).getBalancesByAccountId(accountId, order, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Current Balance for an Account
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    public getCurrentBalance(accountId: string, options?: RawAxiosRequestConfig) {
        return BalancesApiFp(this.configuration).getCurrentBalance(accountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BanksApi - axios parameter creator
 * @export
 */
export const BanksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create or update list of Banks
         * @param {Array<Bank>} [bank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateBanks: async (bank?: Array<Bank>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bank, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Banks
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanks: async (order?: OrderValue, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one Bank by id
         * @param {string} idBank id of the bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanksById: async (idBank: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idBank' is not null or undefined
            assertParamExists('getBanksById', 'idBank', idBank)
            const localVarPath = `/banks/{idBank}`
                .replace(`{${"idBank"}}`, encodeURIComponent(String(idBank)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BanksApi - functional programming interface
 * @export
 */
export const BanksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BanksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary create or update list of Banks
         * @param {Array<Bank>} [bank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateBanks(bank?: Array<Bank>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bank>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateBanks(bank, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BanksApi.crupdateBanks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Banks
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBanks(order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bank>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBanks(order, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BanksApi.getAllBanks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one Bank by id
         * @param {string} idBank id of the bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanksById(idBank: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bank>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanksById(idBank, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BanksApi.getBanksById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BanksApi - factory interface
 * @export
 */
export const BanksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BanksApiFp(configuration)
    return {
        /**
         * 
         * @summary create or update list of Banks
         * @param {Array<Bank>} [bank] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateBanks(bank?: Array<Bank>, options?: any): AxiosPromise<Array<Bank>> {
            return localVarFp.crupdateBanks(bank, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Banks
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanks(order?: OrderValue, orderBy?: string, options?: any): AxiosPromise<Array<Bank>> {
            return localVarFp.getAllBanks(order, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one Bank by id
         * @param {string} idBank id of the bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanksById(idBank: string, options?: any): AxiosPromise<Bank> {
            return localVarFp.getBanksById(idBank, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BanksApi - object-oriented interface
 * @export
 * @class BanksApi
 * @extends {BaseAPI}
 */
export class BanksApi extends BaseAPI {
    /**
     * 
     * @summary create or update list of Banks
     * @param {Array<Bank>} [bank] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BanksApi
     */
    public crupdateBanks(bank?: Array<Bank>, options?: RawAxiosRequestConfig) {
        return BanksApiFp(this.configuration).crupdateBanks(bank, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Banks
     * @param {OrderValue} [order] value of your order by
     * @param {string} [orderBy] string do specify you want to order with what you data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BanksApi
     */
    public getAllBanks(order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig) {
        return BanksApiFp(this.configuration).getAllBanks(order, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one Bank by id
     * @param {string} idBank id of the bank
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BanksApi
     */
    public getBanksById(idBank: string, options?: RawAxiosRequestConfig) {
        return BanksApiFp(this.configuration).getBanksById(idBank, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create or Update list of Categories
         * @param {Array<Category>} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateCategories: async (category?: Array<Category>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Categories
         * @param {CategoryType} [type] Type of category to retrieve
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories: async (type?: CategoryType, order?: OrderValue, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one category by id
         * @param {string} idCategory Id of the category to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById: async (idCategory: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idCategory' is not null or undefined
            assertParamExists('getCategoryById', 'idCategory', idCategory)
            const localVarPath = `/categories/{idCategory}`
                .replace(`{${"idCategory"}}`, encodeURIComponent(String(idCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create or Update list of Categories
         * @param {Array<Category>} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateCategories(category?: Array<Category>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateCategories(category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.crupdateCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Categories
         * @param {CategoryType} [type] Type of category to retrieve
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategories(type?: CategoryType, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(type, order, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.getAllCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one category by id
         * @param {string} idCategory Id of the category to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById(idCategory: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(idCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.getCategoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create or Update list of Categories
         * @param {Array<Category>} [category] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateCategories(category?: Array<Category>, options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.crupdateCategories(category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Categories
         * @param {CategoryType} [type] Type of category to retrieve
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories(type?: CategoryType, order?: OrderValue, orderBy?: string, options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getAllCategories(type, order, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one category by id
         * @param {string} idCategory Id of the category to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById(idCategory: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategoryById(idCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create or Update list of Categories
     * @param {Array<Category>} [category] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public crupdateCategories(category?: Array<Category>, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).crupdateCategories(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Categories
     * @param {CategoryType} [type] Type of category to retrieve
     * @param {OrderValue} [order] value of your order by
     * @param {string} [orderBy] string do specify you want to order with what you data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getAllCategories(type?: CategoryType, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getAllCategories(type, order, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one category by id
     * @param {string} idCategory Id of the category to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoryById(idCategory: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategoryById(idCategory, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create or Update list of Clients
         * @param {Array<Client>} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateClients: async (client?: Array<Client>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all clients
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllClients: async (order?: OrderValue, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one Client using id
         * @param {string} idClient id of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientById: async (idClient: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idClient' is not null or undefined
            assertParamExists('getClientById', 'idClient', idClient)
            const localVarPath = `/clients/{idClient}`
                .replace(`{${"idClient"}}`, encodeURIComponent(String(idClient)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create or Update list of Clients
         * @param {Array<Client>} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateClients(client?: Array<Client>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Client>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateClients(client, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientsApi.crupdateClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all clients
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllClients(order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Client>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllClients(order, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientsApi.getAllClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one Client using id
         * @param {string} idClient id of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientById(idClient: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientById(idClient, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientsApi.getClientById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create or Update list of Clients
         * @param {Array<Client>} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateClients(client?: Array<Client>, options?: any): AxiosPromise<Array<Client>> {
            return localVarFp.crupdateClients(client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all clients
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllClients(order?: OrderValue, orderBy?: string, options?: any): AxiosPromise<Array<Client>> {
            return localVarFp.getAllClients(order, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one Client using id
         * @param {string} idClient id of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientById(idClient: string, options?: any): AxiosPromise<Client> {
            return localVarFp.getClientById(idClient, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * 
     * @summary Create or Update list of Clients
     * @param {Array<Client>} [client] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public crupdateClients(client?: Array<Client>, options?: RawAxiosRequestConfig) {
        return ClientsApiFp(this.configuration).crupdateClients(client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all clients
     * @param {OrderValue} [order] value of your order by
     * @param {string} [orderBy] string do specify you want to order with what you data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getAllClients(order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig) {
        return ClientsApiFp(this.configuration).getAllClients(order, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one Client using id
     * @param {string} idClient id of the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getClientById(idClient: string, options?: RawAxiosRequestConfig) {
        return ClientsApiFp(this.configuration).getClientById(idClient, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all dummies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDummies: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dummy-table`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pong
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all dummies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDummies(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dummy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDummies(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getDummies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Pong
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all dummies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDummies(options?: any): AxiosPromise<Dummy> {
            return localVarFp.getDummies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pong
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Get all dummies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getDummies(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getDummies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary create list of Transaction
         * @param {Array<CreateTransaction>} [createTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactions: async (createTransaction?: Array<CreateTransaction>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Transactions by account id
         * @param {string} accountId Id of the account
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByAccountId: async (accountId: string, order?: OrderValue, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransactionsByAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/transactions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary create list of Transaction
         * @param {Array<CreateTransaction>} [createTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactions(createTransaction?: Array<CreateTransaction>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactions(createTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.createTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all Transactions by account id
         * @param {string} accountId Id of the account
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsByAccountId(accountId: string, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsByAccountId(accountId, order, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionsByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * 
         * @summary create list of Transaction
         * @param {Array<CreateTransaction>} [createTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactions(createTransaction?: Array<CreateTransaction>, options?: any): AxiosPromise<Array<CreateTransaction>> {
            return localVarFp.createTransactions(createTransaction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Transactions by account id
         * @param {string} accountId Id of the account
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsByAccountId(accountId: string, order?: OrderValue, orderBy?: string, options?: any): AxiosPromise<Array<Transaction>> {
            return localVarFp.getTransactionsByAccountId(accountId, order, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary create list of Transaction
     * @param {Array<CreateTransaction>} [createTransaction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransactions(createTransaction?: Array<CreateTransaction>, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransactions(createTransaction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Transactions by account id
     * @param {string} accountId Id of the account
     * @param {OrderValue} [order] value of your order by
     * @param {string} [orderBy] string do specify you want to order with what you data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByAccountId(accountId: string, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsByAccountId(accountId, order, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel one transfer using id
         * @param {string} transferId Id of transfer to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelById: async (transferId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('cancelById', 'transferId', transferId)
            const localVarPath = `/transfers/{transferId}/cancel`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create or update list of Transfers
         * @param {Array<CreateTransfer>} [createTransfer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateTransfers: async (createTransfer?: Array<CreateTransfer>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get one transfer using id
         * @param {string} transferId Id of transfer to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (transferId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('getById', 'transferId', transferId)
            const localVarPath = `/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account\'s Transfer
         * @param {string} accountId Id of the account
         * @param {TransferDirection} [direction] to say in or out or all when retrieve transfers
         * @param {TransferStatus} [status] to say status of transfer when retrieve them
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfersByAccountId: async (accountId: string, direction?: TransferDirection, status?: TransferStatus, order?: OrderValue, orderBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransfersByAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/transfers`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel one transfer using id
         * @param {string} transferId Id of transfer to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelById(transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelById(transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.cancelById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary create or update list of Transfers
         * @param {Array<CreateTransfer>} [createTransfer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateTransfers(createTransfer?: Array<CreateTransfer>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transfer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateTransfers(createTransfer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.crupdateTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get one transfer using id
         * @param {string} transferId Id of transfer to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account\'s Transfer
         * @param {string} accountId Id of the account
         * @param {TransferDirection} [direction] to say in or out or all when retrieve transfers
         * @param {TransferStatus} [status] to say status of transfer when retrieve them
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfersByAccountId(accountId: string, direction?: TransferDirection, status?: TransferStatus, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transfer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfersByAccountId(accountId, direction, status, order, orderBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.getTransfersByAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel one transfer using id
         * @param {string} transferId Id of transfer to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelById(transferId: string, options?: any): AxiosPromise<string> {
            return localVarFp.cancelById(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create or update list of Transfers
         * @param {Array<CreateTransfer>} [createTransfer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateTransfers(createTransfer?: Array<CreateTransfer>, options?: any): AxiosPromise<Array<Transfer>> {
            return localVarFp.crupdateTransfers(createTransfer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get one transfer using id
         * @param {string} transferId Id of transfer to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(transferId: string, options?: any): AxiosPromise<Transfer> {
            return localVarFp.getById(transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account\'s Transfer
         * @param {string} accountId Id of the account
         * @param {TransferDirection} [direction] to say in or out or all when retrieve transfers
         * @param {TransferStatus} [status] to say status of transfer when retrieve them
         * @param {OrderValue} [order] value of your order by
         * @param {string} [orderBy] string do specify you want to order with what you data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfersByAccountId(accountId: string, direction?: TransferDirection, status?: TransferStatus, order?: OrderValue, orderBy?: string, options?: any): AxiosPromise<Array<Transfer>> {
            return localVarFp.getTransfersByAccountId(accountId, direction, status, order, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * 
     * @summary Cancel one transfer using id
     * @param {string} transferId Id of transfer to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public cancelById(transferId: string, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).cancelById(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create or update list of Transfers
     * @param {Array<CreateTransfer>} [createTransfer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public crupdateTransfers(createTransfer?: Array<CreateTransfer>, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).crupdateTransfers(createTransfer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get one transfer using id
     * @param {string} transferId Id of transfer to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getById(transferId: string, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getById(transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account\'s Transfer
     * @param {string} accountId Id of the account
     * @param {TransferDirection} [direction] to say in or out or all when retrieve transfers
     * @param {TransferStatus} [status] to say status of transfer when retrieve them
     * @param {OrderValue} [order] value of your order by
     * @param {string} [orderBy] string do specify you want to order with what you data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getTransfersByAccountId(accountId: string, direction?: TransferDirection, status?: TransferStatus, order?: OrderValue, orderBy?: string, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getTransfersByAccountId(accountId, direction, status, order, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}



