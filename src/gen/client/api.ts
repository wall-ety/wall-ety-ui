/* tslint:disable */
/* eslint-disable */
/**
 * wallety-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {Bank}
   * @memberof Account
   */
  bank?: Bank;
  /**
   *
   * @type {Balance}
   * @memberof Account
   */
  balance?: Balance;
  /**
   *
   * @type {Client}
   * @memberof Account
   */
  client?: Client;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  ref?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  updateAt?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  authorizeCredits?: string;
}
/**
 *
 * @export
 * @interface AccountBase
 */
export interface AccountBase {
  /**
   *
   * @type {string}
   * @memberof AccountBase
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountBase
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof AccountBase
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof AccountBase
   */
  updateAt?: string;
  /**
   *
   * @type {string}
   * @memberof AccountBase
   */
  authorizeCredits?: string;
}
/**
 *
 * @export
 * @interface ApiErrorResponse
 */
export interface ApiErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ApiErrorResponse
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof ApiErrorResponse
   */
  code?: number;
}
/**
 *
 * @export
 * @interface Balance
 */
export interface Balance {
  /**
   *
   * @type {string}
   * @memberof Balance
   */
  id?: string;
  /**
   *
   * @type {number}
   * @memberof Balance
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof Balance
   */
  createdAt?: string;
}
/**
 *
 * @export
 * @interface BalanceInfo
 */
export interface BalanceInfo {
  /**
   *
   * @type {Balance}
   * @memberof BalanceInfo
   */
  balance?: Balance;
  /**
   * borrowed money
   * @type {number}
   * @memberof BalanceInfo
   */
  loan?: number;
  /**
   *
   * @type {number}
   * @memberof BalanceInfo
   */
  loanInterest?: number;
}
/**
 *
 * @export
 * @interface Bank
 */
export interface Bank {
  /**
   *
   * @type {string}
   * @memberof Bank
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Bank
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Bank
   */
  updatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof Bank
   */
  createdAt?: string;
  /**
   *
   * @type {boolean}
   * @memberof Bank
   */
  authorizeCredits?: boolean;
  /**
   *
   * @type {number}
   * @memberof Bank
   */
  firstWeekLoan?: number;
  /**
   *
   * @type {number}
   * @memberof Bank
   */
  subsequentLoan?: number;
}
/**
 *
 * @export
 * @interface Category
 */
export interface Category {
  /**
   *
   * @type {string}
   * @memberof Category
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  updatedAt?: string;
  /**
   *
   * @type {CategoryType}
   * @memberof Category
   */
  type?: CategoryType;
}

/**
 *
 * @export
 * @enum {string}
 */

export const CategoryType = {
  All: "ALL",
  Debit: "DEBIT",
  Credit: "CREDIT",
} as const;

export type CategoryType = (typeof CategoryType)[keyof typeof CategoryType];

/**
 *
 * @export
 * @interface Client
 */
export interface Client {
  /**
   *
   * @type {string}
   * @memberof Client
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  updatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  birthdate?: string;
  /**
   *
   * @type {number}
   * @memberof Client
   */
  monthSalary?: number;
}
/**
 *
 * @export
 * @interface CompleteAccount
 */
export interface CompleteAccount {
  /**
   *
   * @type {string}
   * @memberof CompleteAccount
   */
  ref?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteAccount
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteAccount
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteAccount
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteAccount
   */
  updateAt?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteAccount
   */
  authorizeCredits?: string;
}
/**
 *
 * @export
 * @interface CreateAccount
 */
export interface CreateAccount {
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  idClient?: string;
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  idBank?: string;
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  updateAt?: string;
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  authorizeCredits?: string;
}
/**
 *
 * @export
 * @interface CreateTransaction
 */
export interface CreateTransaction {
  /**
   *
   * @type {string}
   * @memberof CreateTransaction
   */
  idAccount?: string;
  /**
   *
   * @type {string}
   * @memberof CreateTransaction
   */
  id?: string;
  /**
   *
   * @type {TransactionType}
   * @memberof CreateTransaction
   */
  type?: TransactionType;
  /**
   *
   * @type {string}
   * @memberof CreateTransaction
   */
  reason?: string;
  /**
   *
   * @type {number}
   * @memberof CreateTransaction
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof CreateTransaction
   */
  transactionDatetime?: string;
  /**
   *
   * @type {string}
   * @memberof CreateTransaction
   */
  label?: string;
}

/**
 *
 * @export
 * @interface CreateTransfer
 */
export interface CreateTransfer {
  /**
   *
   * @type {string}
   * @memberof CreateTransfer
   */
  sourceId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateTransfer
   */
  destinationId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateTransfer
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CreateTransfer
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof CreateTransfer
   */
  effectiveDate?: string;
  /**
   *
   * @type {string}
   * @memberof CreateTransfer
   */
  reason?: string;
  /**
   *
   * @type {TransferStatus}
   * @memberof CreateTransfer
   */
  status?: TransferStatus;
  /**
   *
   * @type {string}
   * @memberof CreateTransfer
   */
  label?: string;
}

/**
 *
 * @export
 * @interface Dummy
 */
export interface Dummy {
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  name?: string;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {Account}
   * @memberof Transaction
   */
  account?: Account;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  id?: string;
  /**
   *
   * @type {TransactionType}
   * @memberof Transaction
   */
  type?: TransactionType;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  reason?: string;
  /**
   *
   * @type {number}
   * @memberof Transaction
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transactionDatetime?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  label?: string;
}

/**
 *
 * @export
 * @interface TransactionBase
 */
export interface TransactionBase {
  /**
   *
   * @type {string}
   * @memberof TransactionBase
   */
  id?: string;
  /**
   *
   * @type {TransactionType}
   * @memberof TransactionBase
   */
  type?: TransactionType;
  /**
   *
   * @type {string}
   * @memberof TransactionBase
   */
  reason?: string;
  /**
   *
   * @type {number}
   * @memberof TransactionBase
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof TransactionBase
   */
  transactionDatetime?: string;
  /**
   *
   * @type {string}
   * @memberof TransactionBase
   */
  label?: string;
}

/**
 *
 * @export
 * @enum {string}
 */

export const TransactionType = {
  Debit: "DEBIT",
  Credit: "CREDIT",
} as const;

export type TransactionType =
  (typeof TransactionType)[keyof typeof TransactionType];

/**
 *
 * @export
 * @interface Transfer
 */
export interface Transfer {
  /**
   *
   * @type {Client}
   * @memberof Transfer
   */
  source?: Client;
  /**
   *
   * @type {Client}
   * @memberof Transfer
   */
  destination?: Client;
  /**
   *
   * @type {string}
   * @memberof Transfer
   */
  sourceId?: string;
  /**
   *
   * @type {string}
   * @memberof Transfer
   */
  destinationId?: string;
  /**
   *
   * @type {string}
   * @memberof Transfer
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Transfer
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof Transfer
   */
  effectiveDate?: string;
  /**
   *
   * @type {string}
   * @memberof Transfer
   */
  reason?: string;
  /**
   *
   * @type {TransferStatus}
   * @memberof Transfer
   */
  status?: TransferStatus;
  /**
   *
   * @type {string}
   * @memberof Transfer
   */
  label?: string;
}

/**
 *
 * @export
 * @interface TransferBase
 */
export interface TransferBase {
  /**
   *
   * @type {string}
   * @memberof TransferBase
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof TransferBase
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof TransferBase
   */
  effectiveDate?: string;
  /**
   *
   * @type {string}
   * @memberof TransferBase
   */
  reason?: string;
  /**
   *
   * @type {TransferStatus}
   * @memberof TransferBase
   */
  status?: TransferStatus;
  /**
   *
   * @type {string}
   * @memberof TransferBase
   */
  label?: string;
}

/**
 *
 * @export
 * @enum {string}
 */

export const TransferStatus = {
  Pending: "PENDING",
  Completed: "COMPLETED",
  Cancelled: "CANCELLED",
} as const;

export type TransferStatus =
  (typeof TransferStatus)[keyof typeof TransferStatus];

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create or Update list of Accounts
     * @param {Array<CreateAccount>} [createAccount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAccounts: async (
      createAccount?: Array<CreateAccount>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAccount,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get one Account using id
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountById: async (
      accountId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("getAccountById", "accountId", accountId);
      const localVarPath = `/accounts/{accountId}`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAccounts: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create or Update list of Accounts
     * @param {Array<CreateAccount>} [createAccount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateAccounts(
      createAccount?: Array<CreateAccount>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateAccounts(
          createAccount,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.crupdateAccounts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get one Account using id
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountById(
      accountId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountById(
        accountId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.getAccountById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllAccounts(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllAccounts(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AccountsApi.getAllAccounts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     *
     * @summary Create or Update list of Accounts
     * @param {Array<CreateAccount>} [createAccount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAccounts(
      createAccount?: Array<CreateAccount>,
      options?: any
    ): AxiosPromise<Array<Account>> {
      return localVarFp
        .crupdateAccounts(createAccount, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get one Account using id
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountById(accountId: string, options?: any): AxiosPromise<Account> {
      return localVarFp
        .getAccountById(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAccounts(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .getAllAccounts(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   *
   * @summary Create or Update list of Accounts
   * @param {Array<CreateAccount>} [createAccount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public crupdateAccounts(
    createAccount?: Array<CreateAccount>,
    options?: RawAxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .crupdateAccounts(createAccount, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get one Account using id
   * @param {string} accountId Id of the account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccountById(accountId: string, options?: RawAxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getAccountById(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all Account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAllAccounts(options?: RawAxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .getAllAccounts(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BalancesApi - axios parameter creator
 * @export
 */
export const BalancesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get All Balance by AccountId
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalancesByAccountId: async (
      accountId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("getBalancesByAccountId", "accountId", accountId);
      const localVarPath = `/accounts/{accountId}/balances`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Current Balance for an Account
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentBalance: async (
      accountId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("getCurrentBalance", "accountId", accountId);
      const localVarPath = `/accounts/{accountId}/balances/current`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BalancesApi - functional programming interface
 * @export
 */
export const BalancesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BalancesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get All Balance by AccountId
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBalancesByAccountId(
      accountId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Balance>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBalancesByAccountId(
          accountId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BalancesApi.getBalancesByAccountId"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Current Balance for an Account
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentBalance(
      accountId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCurrentBalance(accountId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BalancesApi.getCurrentBalance"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BalancesApi - factory interface
 * @export
 */
export const BalancesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BalancesApiFp(configuration);
  return {
    /**
     *
     * @summary Get All Balance by AccountId
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalancesByAccountId(
      accountId: string,
      options?: any
    ): AxiosPromise<Array<Balance>> {
      return localVarFp
        .getBalancesByAccountId(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Current Balance for an Account
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentBalance(
      accountId: string,
      options?: any
    ): AxiosPromise<BalanceInfo> {
      return localVarFp
        .getCurrentBalance(accountId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
export class BalancesApi extends BaseAPI {
  /**
   *
   * @summary Get All Balance by AccountId
   * @param {string} accountId Id of the account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BalancesApi
   */
  public getBalancesByAccountId(
    accountId: string,
    options?: RawAxiosRequestConfig
  ) {
    return BalancesApiFp(this.configuration)
      .getBalancesByAccountId(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Current Balance for an Account
   * @param {string} accountId Id of the account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BalancesApi
   */
  public getCurrentBalance(accountId: string, options?: RawAxiosRequestConfig) {
    return BalancesApiFp(this.configuration)
      .getCurrentBalance(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BanksApi - axios parameter creator
 * @export
 */
export const BanksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary create or update list of Banks
     * @param {Array<Bank>} [bank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateBanks: async (
      bank?: Array<Bank>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/banks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bank,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get All Banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanks: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/banks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get one Bank by id
     * @param {string} idBank id of the bank to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanksById: async (
      idBank: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'idBank' is not null or undefined
      assertParamExists("getBanksById", "idBank", idBank);
      const localVarPath = `/banks/{idBank}`.replace(
        `{${"idBank"}}`,
        encodeURIComponent(String(idBank))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BanksApi - functional programming interface
 * @export
 */
export const BanksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BanksApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary create or update list of Banks
     * @param {Array<Bank>} [bank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateBanks(
      bank?: Array<Bank>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bank>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateBanks(
        bank,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BanksApi.crupdateBanks"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get All Banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllBanks(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bank>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllBanks(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BanksApi.getAllBanks"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get one Bank by id
     * @param {string} idBank id of the bank to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBanksById(
      idBank: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bank>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBanksById(
        idBank,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BanksApi.getBanksById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BanksApi - factory interface
 * @export
 */
export const BanksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BanksApiFp(configuration);
  return {
    /**
     *
     * @summary create or update list of Banks
     * @param {Array<Bank>} [bank]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateBanks(
      bank?: Array<Bank>,
      options?: any
    ): AxiosPromise<Array<Bank>> {
      return localVarFp
        .crupdateBanks(bank, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get All Banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBanks(options?: any): AxiosPromise<Array<Bank>> {
      return localVarFp
        .getAllBanks(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get one Bank by id
     * @param {string} idBank id of the bank to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanksById(idBank: string, options?: any): AxiosPromise<Bank> {
      return localVarFp
        .getBanksById(idBank, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BanksApi - object-oriented interface
 * @export
 * @class BanksApi
 * @extends {BaseAPI}
 */
export class BanksApi extends BaseAPI {
  /**
   *
   * @summary create or update list of Banks
   * @param {Array<Bank>} [bank]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BanksApi
   */
  public crupdateBanks(bank?: Array<Bank>, options?: RawAxiosRequestConfig) {
    return BanksApiFp(this.configuration)
      .crupdateBanks(bank, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get All Banks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BanksApi
   */
  public getAllBanks(options?: RawAxiosRequestConfig) {
    return BanksApiFp(this.configuration)
      .getAllBanks(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get one Bank by id
   * @param {string} idBank id of the bank to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BanksApi
   */
  public getBanksById(idBank: string, options?: RawAxiosRequestConfig) {
    return BanksApiFp(this.configuration)
      .getBanksById(idBank, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create or Update list of Categories
     * @param {Array<Category>} [category]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCategories: async (
      category?: Array<Category>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/categories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        category,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get All Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCategories: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/categories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get one category by id
     * @param {string} idCategory Id of the category to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategoryById: async (
      idCategory: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'idCategory' is not null or undefined
      assertParamExists("getCategoryById", "idCategory", idCategory);
      const localVarPath = `/categories/{idCategory}`.replace(
        `{${"idCategory"}}`,
        encodeURIComponent(String(idCategory))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CategoriesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create or Update list of Categories
     * @param {Array<Category>} [category]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateCategories(
      category?: Array<Category>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Category>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateCategories(category, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CategoriesApi.crupdateCategories"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get All Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllCategories(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Category>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllCategories(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CategoriesApi.getAllCategories"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get one category by id
     * @param {string} idCategory Id of the category to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCategoryById(
      idCategory: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(
        idCategory,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CategoriesApi.getCategoryById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CategoriesApiFp(configuration);
  return {
    /**
     *
     * @summary Create or Update list of Categories
     * @param {Array<Category>} [category]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCategories(
      category?: Array<Category>,
      options?: any
    ): AxiosPromise<Array<Category>> {
      return localVarFp
        .crupdateCategories(category, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get All Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCategories(options?: any): AxiosPromise<Array<Category>> {
      return localVarFp
        .getAllCategories(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get one category by id
     * @param {string} idCategory Id of the category to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategoryById(idCategory: string, options?: any): AxiosPromise<Category> {
      return localVarFp
        .getCategoryById(idCategory, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
  /**
   *
   * @summary Create or Update list of Categories
   * @param {Array<Category>} [category]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public crupdateCategories(
    category?: Array<Category>,
    options?: RawAxiosRequestConfig
  ) {
    return CategoriesApiFp(this.configuration)
      .crupdateCategories(category, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get All Categories
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public getAllCategories(options?: RawAxiosRequestConfig) {
    return CategoriesApiFp(this.configuration)
      .getAllCategories(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get one category by id
   * @param {string} idCategory Id of the category to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public getCategoryById(idCategory: string, options?: RawAxiosRequestConfig) {
    return CategoriesApiFp(this.configuration)
      .getCategoryById(idCategory, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create or Update list of Clients
     * @param {Array<Client>} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateClients: async (
      client?: Array<Client>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/clients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        client,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllClients: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/clients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get one Client using id
     * @param {string} idClient id of the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientById: async (
      idClient: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'idClient' is not null or undefined
      assertParamExists("getClientById", "idClient", idClient);
      const localVarPath = `/clients/{idClient}`.replace(
        `{${"idClient"}}`,
        encodeURIComponent(String(idClient))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create or Update list of Clients
     * @param {Array<Client>} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateClients(
      client?: Array<Client>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Client>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateClients(
        client,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ClientsApi.crupdateClients"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllClients(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Client>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllClients(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ClientsApi.getAllClients"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get one Client using id
     * @param {string} idClient id of the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClientById(
      idClient: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClientById(
        idClient,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ClientsApi.getClientById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClientsApiFp(configuration);
  return {
    /**
     *
     * @summary Create or Update list of Clients
     * @param {Array<Client>} [client]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateClients(
      client?: Array<Client>,
      options?: any
    ): AxiosPromise<Array<Client>> {
      return localVarFp
        .crupdateClients(client, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllClients(options?: any): AxiosPromise<Array<Client>> {
      return localVarFp
        .getAllClients(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get one Client using id
     * @param {string} idClient id of the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientById(idClient: string, options?: any): AxiosPromise<Client> {
      return localVarFp
        .getClientById(idClient, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
  /**
   *
   * @summary Create or Update list of Clients
   * @param {Array<Client>} [client]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public crupdateClients(
    client?: Array<Client>,
    options?: RawAxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .crupdateClients(client, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all clients
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public getAllClients(options?: RawAxiosRequestConfig) {
    return ClientsApiFp(this.configuration)
      .getAllClients(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get one Client using id
   * @param {string} idClient id of the client
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public getClientById(idClient: string, options?: RawAxiosRequestConfig) {
    return ClientsApiFp(this.configuration)
      .getClientById(idClient, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get all dummies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dummy-table`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get all dummies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDummies(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dummy>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDummies(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.getDummies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.ping"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     *
     * @summary Get all dummies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies(options?: any): AxiosPromise<Dummy> {
      return localVarFp
        .getDummies(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Pong
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp
        .ping(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @summary Get all dummies
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getDummies(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .getDummies(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Pong
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .ping(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary create list of Transaction
     * @param {Array<CreateTransaction>} [createTransaction]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransactions: async (
      createTransaction?: Array<CreateTransaction>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTransaction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all Transactions by account id
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsByAccountId: async (
      accountId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("getTransactionsByAccountId", "accountId", accountId);
      const localVarPath = `/accounts/{accountId}/transactions`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransactionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary create list of Transaction
     * @param {Array<CreateTransaction>} [createTransaction]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTransactions(
      createTransaction?: Array<CreateTransaction>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CreateTransaction>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createTransactions(
          createTransaction,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionsApi.createTransactions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all Transactions by account id
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransactionsByAccountId(
      accountId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Transaction>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransactionsByAccountId(
          accountId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransactionsApi.getTransactionsByAccountId"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TransactionsApiFp(configuration);
  return {
    /**
     *
     * @summary create list of Transaction
     * @param {Array<CreateTransaction>} [createTransaction]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransactions(
      createTransaction?: Array<CreateTransaction>,
      options?: any
    ): AxiosPromise<Array<CreateTransaction>> {
      return localVarFp
        .createTransactions(createTransaction, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all Transactions by account id
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactionsByAccountId(
      accountId: string,
      options?: any
    ): AxiosPromise<Array<Transaction>> {
      return localVarFp
        .getTransactionsByAccountId(accountId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
  /**
   *
   * @summary create list of Transaction
   * @param {Array<CreateTransaction>} [createTransaction]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public createTransactions(
    createTransaction?: Array<CreateTransaction>,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionsApiFp(this.configuration)
      .createTransactions(createTransaction, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all Transactions by account id
   * @param {string} accountId Id of the account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public getTransactionsByAccountId(
    accountId: string,
    options?: RawAxiosRequestConfig
  ) {
    return TransactionsApiFp(this.configuration)
      .getTransactionsByAccountId(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary create or update list of Transfers
     * @param {Array<CreateTransfer>} [createTransfer]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateTransfers: async (
      createTransfer?: Array<CreateTransfer>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/transfers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTransfer,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get account\'s Transfer
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfersByAccountId: async (
      accountId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("getTransfersByAccountId", "accountId", accountId);
      const localVarPath = `/accounts/{accountId}/transfers`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransfersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary create or update list of Transfers
     * @param {Array<CreateTransfer>} [createTransfer]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateTransfers(
      createTransfer?: Array<CreateTransfer>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Transfer>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateTransfers(
          createTransfer,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransfersApi.crupdateTransfers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get account\'s Transfer
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTransfersByAccountId(
      accountId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Transfer>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTransfersByAccountId(
          accountId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TransfersApi.getTransfersByAccountId"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TransfersApiFp(configuration);
  return {
    /**
     *
     * @summary create or update list of Transfers
     * @param {Array<CreateTransfer>} [createTransfer]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateTransfers(
      createTransfer?: Array<CreateTransfer>,
      options?: any
    ): AxiosPromise<Array<Transfer>> {
      return localVarFp
        .crupdateTransfers(createTransfer, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get account\'s Transfer
     * @param {string} accountId Id of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfersByAccountId(
      accountId: string,
      options?: any
    ): AxiosPromise<Array<Transfer>> {
      return localVarFp
        .getTransfersByAccountId(accountId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
  /**
   *
   * @summary create or update list of Transfers
   * @param {Array<CreateTransfer>} [createTransfer]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransfersApi
   */
  public crupdateTransfers(
    createTransfer?: Array<CreateTransfer>,
    options?: RawAxiosRequestConfig
  ) {
    return TransfersApiFp(this.configuration)
      .crupdateTransfers(createTransfer, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get account\'s Transfer
   * @param {string} accountId Id of the account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransfersApi
   */
  public getTransfersByAccountId(
    accountId: string,
    options?: RawAxiosRequestConfig
  ) {
    return TransfersApiFp(this.configuration)
      .getTransfersByAccountId(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
